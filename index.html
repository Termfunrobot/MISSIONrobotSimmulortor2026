<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Robot Control Simulator - ระบบจำลองหุ่นยนต์</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Sarabun:wght@300;400;600&display=swap');
        
        :root {
            --bg-main: #0f172a;
            --bg-nav: rgba(15, 23, 42, 0.8);
            --bg-card: #0f172a;
            --border-color: #1e293b;
            --text-main: #f1f5f9;
            --grid-color: rgba(30, 41, 59, 0.4);
        }

        .light-mode {
            --bg-main: #f8fafc;
            --bg-nav: rgba(248, 250, 252, 0.8);
            --bg-card: #ffffff;
            --border-color: #e2e8f0;
            --text-main: #0f172a;
            --grid-color: rgba(148, 163, 184, 0.2);
        }

        body {
            font-family: 'Sarabun', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            overflow-x: hidden;
            touch-action: manipulation;
            transition: background-color 0.3s, color 0.3s;
        }

        .terminal-font {
            font-family: 'JetBrains Mono', monospace;
        }

        canvas {
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 40px 40px;
            background-color: var(--bg-card);
            touch-action: none;
            transition: background-color 0.3s;
        }

        .joystick-btn {
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: none;
            transition: all 0.1s;
        }
        
        .joystick-btn:active {
            transform: translateY(2px);
            filter: brightness(1.2);
        }

        .joystick-grid {
            display: grid;
            grid-template-areas: 
                ". up ."
                "left . right"
                ". down .";
            gap: 12px;
        }

        .score-animate {
            animation: pulse-score 0.5s ease-out;
        }

        @keyframes pulse-score {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #22c55e; }
            100% { transform: scale(1); }
        }

        .light-mode .bg-slate-900\/50 { background-color: rgba(226, 232, 240, 0.5); }
        .light-mode .bg-slate-900 { background-color: #ffffff; }
        .light-mode .bg-slate-800 { background-color: #f1f5f9; color: #1e293b; border-bottom-color: #cbd5e1; }
        .light-mode .border-slate-800 { border-color: #e2e8f0; }

        input[type=range] {
            accent-color: #6366f1;
        }

        .hidden-element { display: none !important; }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <nav class="border-b border-slate-800 bg-slate-900/80 backdrop-blur-md sticky top-0 z-50 transition-colors">
        <div class="max-w-6xl mx-auto px-4 py-2 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <div class="w-8 h-8 bg-blue-600 rounded flex items-center justify-center shadow-lg">
                    <i class="fas fa-robot text-white text-sm"></i>
                </div>
                <div>
                    <h1 class="text-sm font-bold tracking-tight">ROBO-PRO v3.9.1</h1>
                    <p id="statusLabel" class="text-[9px] text-blue-400 terminal-font uppercase tracking-tighter">Status: System Ready</p>
                    <p id="timerLabel" class="text-[9px] text-emerald-400 terminal-font uppercase tracking-tighter hidden-element">Mission Time: <span id="missionTime">00:00</span></p>
                </div>
            </div>
            <div class="flex items-center space-x-3">
                <button onclick="toggleTheme()" ontouchstart="toggleTheme()" class="w-10 h-10 rounded-full flex items-center justify-center bg-slate-800 text-yellow-500 hover:bg-slate-700 transition-colors shadow-md border border-slate-700 dark-toggle-btn">
                    <i id="themeIcon" class="fas fa-moon"></i>
                </button>
                <div class="text-right">
                    <p id="scoreDisplay" class="text-xl font-bold text-yellow-500 terminal-font">000</p>
                </div>
                <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
            </div>
        </div>
    </nav>

    <main class="flex-grow flex flex-col max-w-6xl mx-auto w-full p-2 gap-2">
        <!-- Canvas Area -->
        <div id="canvasContainer" class="bg-slate-900 border border-slate-800 rounded-xl overflow-hidden shadow-2xl relative flex-grow min-h-[350px] transition-colors">
            <div class="absolute top-2 left-2 z-10 pointer-events-none">
                <div class="bg-slate-900/90 backdrop-blur p-2 rounded-lg border border-slate-700 text-[10px] terminal-font space-y-1 shadow-xl info-panel">
                    <p class="text-slate-400">POS: <span id="valX" class="text-blue-400">0</span>, <span id="valY" class="text-blue-400">0</span></p>
                    <p class="text-slate-400">CARGO: <span id="valCargo" class="text-orange-400 font-bold uppercase">EMPTY</span></p>
                </div>
            </div>
            
            <canvas id="robotCanvas" class="w-full h-full"></canvas>

            <div class="absolute bottom-2 right-2 flex flex-col gap-2">
                <button onclick="resetRobotToCenter()" ontouchstart="resetRobotToCenter()" class="bg-slate-800/90 p-3 rounded-xl text-xs joystick-btn border border-slate-700 text-white">
                    <i class="fas fa-street-view text-lg"></i>
                </button>
            </div>

            <!-- Start Mission Overlay -->
            <div id="startOverlay" class="absolute inset-0 flex items-center justify-center bg-slate-900/40 backdrop-blur-sm z-20">
                <button onclick="startMission()" ontouchstart="startMission()" class="bg-blue-600 hover:bg-blue-500 text-white px-10 py-4 rounded-2xl font-bold text-xl shadow-2xl border-b-4 border-blue-900 joystick-btn flex items-center gap-3">
                    <i class="fas fa-play"></i> เริ่มภารกิจ
                </button>
            </div>
        </div>

        <!-- Bottom Controls Area -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-2 pb-4">
            <!-- Left: Config & Setup -->
            <div id="setupControls" class="bg-slate-900/50 border border-slate-800 p-4 rounded-2xl flex flex-col gap-3 transition-colors">
                <div class="flex-grow flex flex-col justify-center gap-2">
                    <div id="wallPanel" class="flex flex-col gap-1">
                        <label class="text-[11px] terminal-font text-slate-300 uppercase flex justify-between">
                            ความหนาแน่นกำแพง <span><span id="densityVal">25</span>%</span>
                        </label>
                        <input type="range" id="wallDensity" min="10" max="70" value="25" step="5" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="grid grid-cols-2 gap-2 mt-1">
                        <button id="randomWallBtn" onclick="generateWalls()" ontouchstart="generateWalls()" class="bg-indigo-600 hover:bg-indigo-500 py-3 rounded-xl text-xs font-bold text-white shadow-lg joystick-btn border-b-4 border-indigo-900">
                            <i class="fas fa-th mr-1"></i> สุ่มกำแพง
                        </button>
                        <button id="addObjectBtn" onclick="spawnObject()" ontouchstart="spawnObject()" class="bg-emerald-600 hover:bg-emerald-500 py-3 rounded-xl text-xs font-bold text-white shadow-lg joystick-btn border-b-4 border-emerald-900">
                            <i class="fas fa-plus mr-1"></i> เพิ่มวัตถุ
                        </button>
                    </div>
                    <button onclick="resetWholeMission()" ontouchstart="resetWholeMission()" class="bg-red-600 hover:bg-red-500 py-3 rounded-xl text-xs font-bold shadow-lg joystick-btn border-b-4 border-red-900 text-white"><i class="fas fa-sync-alt mr-2"></i> รีเซ็ตภารกิจ</button>
                </div>
            </div>

            <!-- Middle: Joystick -->
            <div class="bg-slate-900/50 border border-slate-800 p-4 rounded-2xl flex items-center justify-center transition-colors">
                <div class="joystick-grid">
                    <button ontouchstart="startMove('up', event)" ontouchend="stopMove(event)" onmousedown="startMove('up')" onmouseup="stopMove()" class="joystick-btn w-16 h-16 bg-slate-800 active:bg-blue-600 rounded-2xl flex items-center justify-center text-3xl shadow-xl border-b-4 border-slate-950 text-white" style="grid-area: up;"><i class="fas fa-caret-up"></i></button>
                    <button ontouchstart="startMove('left', event)" ontouchend="stopMove(event)" onmousedown="startMove('left')" onmouseup="stopMove()" class="joystick-btn w-16 h-16 bg-slate-800 active:bg-blue-600 rounded-2xl flex items-center justify-center text-3xl shadow-xl border-b-4 border-slate-950 text-white" style="grid-area: left;"><i class="fas fa-caret-left"></i></button>
                    <button ontouchstart="startMove('right', event)" ontouchend="stopMove(event)" onmousedown="startMove('right')" onmouseup="stopMove()" class="joystick-btn w-16 h-16 bg-slate-800 active:bg-blue-600 rounded-2xl flex items-center justify-center text-3xl shadow-xl border-b-4 border-slate-950 text-white" style="grid-area: right;"><i class="fas fa-caret-right"></i></button>
                    <button ontouchstart="startMove('down', event)" ontouchend="stopMove(event)" onmousedown="startMove('down')" onmouseup="stopMove()" class="joystick-btn w-16 h-16 bg-slate-800 active:bg-blue-600 rounded-2xl flex items-center justify-center text-3xl shadow-xl border-b-4 border-slate-950 text-white" style="grid-area: down;"><i class="fas fa-caret-down"></i></button>
                </div>
            </div>

            <!-- Right: Gripper & Rotation -->
            <div class="bg-slate-900/50 border border-slate-800 p-4 rounded-2xl flex flex-col gap-2 transition-colors">
                <div class="grid grid-cols-2 gap-2 flex-grow">
                    <button onclick="setGripper(false)" ontouchstart="setGripper(false)" class="bg-orange-600 active:bg-orange-500 rounded-2xl text-xs font-bold shadow-lg flex flex-col items-center justify-center joystick-btn border-b-4 border-orange-900 text-white"><i class="fas fa-hand-grab text-2xl mb-1"></i>คีบ</button>
                    <button onclick="setGripper(true)" ontouchstart="setGripper(true)" class="bg-slate-700 active:bg-slate-600 rounded-2xl text-xs font-bold shadow-lg flex flex-col items-center justify-center joystick-btn border-b-4 border-slate-900 text-white"><i class="fas fa-hand-paper text-2xl mb-1"></i>วาง</button>
                </div>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="rotateRobot(-20)" ontouchstart="rotateRobot(-20)" class="bg-slate-800 active:bg-indigo-600 py-4 rounded-2xl joystick-btn border-b-4 border-slate-950 text-white text-xl"><i class="fas fa-undo"></i></button>
                    <button onclick="rotateRobot(20)" ontouchstart="rotateRobot(20)" class="bg-slate-800 active:bg-indigo-600 py-4 rounded-2xl joystick-btn border-b-4 border-slate-950 text-white text-xl"><i class="fas fa-redo"></i></button>
                </div>
            </div>
        </div>
    </main>

    <script>
        /**
         * AUDIO SYSTEM: สังเคราะห์เสียงด้วย Web Audio API
         */
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.motorOsc = null;
                this.motorGain = null;
                this.isMotorRunning = false;
            }

            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }

            // เสียงคลิกปุ่ม UI
            playClick() {
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1000, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            // เสียงมอเตอร์ (Motor Sound)
            startMotor() {
                this.init();
                if (this.isMotorRunning) return;
                this.isMotorRunning = true;

                this.motorOsc = this.ctx.createOscillator();
                this.motorGain = this.ctx.createGain();
                this.motorOsc.type = 'sawtooth';
                this.motorOsc.frequency.setValueAtTime(50, this.ctx.currentTime);
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                this.motorGain.gain.setValueAtTime(0, this.ctx.currentTime);
                this.motorGain.gain.linearRampToValueAtTime(0.04, this.ctx.currentTime + 0.1);

                this.motorOsc.connect(filter);
                filter.connect(this.motorGain);
                this.motorGain.connect(this.ctx.destination);
                this.motorOsc.start();
            }

            stopMotor() {
                if (!this.isMotorRunning) return;
                this.isMotorRunning = false;
                if (this.motorGain) {
                    this.motorGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                    setTimeout(() => { if (this.motorOsc) this.motorOsc.stop(); }, 100);
                }
            }

            // เสียงคีบ/วาง (Gripper Sound)
            playGripper() {
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(350, this.ctx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
            }

            // เสียงทำคะแนนได้ (Score Sound)
            playScore() {
                this.init();
                const now = this.ctx.currentTime;
                const playBeep = (freq, time, dur) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.setValueAtTime(freq, time);
                    gain.gain.setValueAtTime(0.1, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + dur);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(time); osc.stop(time + dur);
                };
                playBeep(880, now, 0.1);
                playBeep(1320, now + 0.12, 0.2);
            }
        }

        const sounds = new SoundManager();

        // Polyfill for roundRect
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (typeof r === 'undefined') r = 0;
                if (typeof r === 'number') r = {tl: r, tr: r, br: r, bl: r};
                this.beginPath();
                this.moveTo(x + r.tl, y);
                this.lineTo(x + w - r.tr, y);
                this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
                this.lineTo(x + w, y + h - r.br);
                this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
                this.lineTo(x + r.bl, y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
                this.lineTo(x, r.tl + y); 
                this.lineTo(x, y + r.tl);
                this.quadraticCurveTo(x, y, x + r.tl, y);
                this.closePath();
                return this;
            };
        }

        const canvas = document.getElementById('robotCanvas');
        const ctx = canvas.getContext('2d');
        const wallSlider = document.getElementById('wallDensity');
        const densityDisplay = document.getElementById('densityVal');

        const COLORS = { 
            YELLOW: '#fbbf24', 
            GREEN: '#059669',
            RED: '#ef4444', 
            BLUE: '#3b82f6' 
        };
        const OBJECT_COLORS = [COLORS.YELLOW, COLORS.GREEN, COLORS.RED, COLORS.BLUE]; 
        const GRAB_DISTANCE = 45; 
        const DROP_ZONE_SIZE = 64;
        const GRID_CELL = 40;
        
        const WALL_W = GRID_CELL; 
        const WALL_H = GRID_CELL / 2;

        let robot = {
            x: 0, y: 0, angle: -90, 
            gripperOpen: true, gripperValue: 0, 
            attachedObject: null, 
            pulse: 0
        };

        let objects = []; 
        let dropZones = [];
        let walls = []; 
        let score = 0;
        let moveState = { up: false, down: false, left: false, right: false };
        let isDarkMode = true;

        let startTime = null;
        let timerInterval = null;
        let isMissionStarted = false;

        window.onload = () => {
            resizeCanvas();
            initMission();
            requestAnimationFrame(update);
        };

        window.addEventListener('resize', resizeCanvas);
        wallSlider.addEventListener('input', (e) => densityDisplay.innerText = e.target.value);

        function startMission() {
            sounds.playClick();
            isMissionStarted = true;
            document.getElementById('startOverlay').classList.add('hidden-element');
            
            document.getElementById('randomWallBtn').disabled = true;
            document.getElementById('randomWallBtn').classList.add('opacity-30', 'grayscale');
            document.getElementById('addObjectBtn').disabled = true;
            document.getElementById('addObjectBtn').classList.add('opacity-30', 'grayscale');
            document.getElementById('wallDensity').disabled = true;

            document.getElementById('statusLabel').classList.add('hidden-element');
            document.getElementById('timerLabel').classList.remove('hidden-element');
            
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            if (!startTime) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('missionTime').innerText = `${mins}:${secs}`;
        }

        function generateWalls() {
            if(isMissionStarted) return;
            walls = [];
            const density = parseInt(wallSlider.value) / 100;
            const cols = Math.floor(canvas.width / GRID_CELL);
            const rows = Math.floor(canvas.height / GRID_CELL);

            for(let r = 0; r < rows; r++) {
                for(let c = 0; c < cols; c++) {
                    const worldX = c * GRID_CELL + GRID_CELL/2;
                    const worldY = r * GRID_CELL + GRID_CELL/2;
                    
                    const isNearCenter = Math.hypot(worldX - canvas.width/2, worldY - canvas.height/2) < 100;
                    let isNearDropZone = false;
                    dropZones.forEach(z => {
                        if(Math.hypot(worldX - z.x, worldY - z.y) < 80) isNearDropZone = true;
                    });

                    if(!isNearCenter && !isNearDropZone && Math.random() < density) {
                        walls.push({
                            r, c, 
                            x: c * GRID_CELL, 
                            y: r * GRID_CELL + (GRID_CELL - WALL_H) / 2
                        });
                    }
                }
            }
            objects = objects.filter(obj => !isPointInWall(obj.x, obj.y));
        }

        function isPointInWall(x, y) {
            const buffer = 16;
            return walls.some(w => {
                return x + buffer > w.x && 
                       x - buffer < w.x + WALL_W && 
                       y + buffer > w.y && 
                       y - buffer < w.y + WALL_H;
            });
        }

        function toggleTheme() {
            sounds.playClick();
            isDarkMode = !isDarkMode;
            if (isDarkMode) document.body.classList.remove('light-mode');
            else document.body.classList.add('light-mode');
            document.getElementById('themeIcon').className = isDarkMode ? 'fas fa-moon' : 'fas fa-sun';
        }

        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            if(!container) return;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (robot.x === 0) resetRobotToCenter();
            initDropZones();
            generateWalls();
        }

        function initDropZones() {
            const margin = 60;
            dropZones = [
                { x: margin, y: 100, color: COLORS.YELLOW, label: 'YELLOW' },
                { x: margin, y: canvas.height - 100, color: COLORS.GREEN, label: 'GREEN' },
                { x: canvas.width - margin, y: 100, color: COLORS.RED, label: 'RED' },
                { x: canvas.width - margin, y: canvas.height - 100, color: COLORS.BLUE, label: 'BLUE' }
            ];
        }

        function resetRobotToCenter() {
            sounds.playClick();
            robot.x = canvas.width / 2;
            robot.y = canvas.height / 2;
            robot.angle = -90;
        }

        function resetWholeMission() {
            sounds.playClick();
            isMissionStarted = false;
            clearInterval(timerInterval);
            startTime = null;
            document.getElementById('missionTime').innerText = "00:00";
            
            document.getElementById('startOverlay').classList.remove('hidden-element');
            document.getElementById('statusLabel').classList.remove('hidden-element');
            document.getElementById('timerLabel').classList.add('hidden-element');

            document.getElementById('randomWallBtn').disabled = false;
            document.getElementById('randomWallBtn').classList.remove('opacity-30', 'grayscale');
            document.getElementById('addObjectBtn').disabled = false;
            document.getElementById('addObjectBtn').classList.remove('opacity-30', 'grayscale');
            document.getElementById('wallDensity').disabled = false;

            objects = []; walls = []; robot.attachedObject = null; robot.gripperOpen = true;
            score = 0; updateScoreUI(); resetRobotToCenter(); generateWalls();
        }

        function initMission() { score = 0; updateScoreUI(); }

        function spawnObject() {
            sounds.playClick();
            if(isMissionStarted) return;
            const padding = 120;
            for(let i=0; i<20; i++) {
                const nx = padding + Math.random() * (canvas.width - padding * 2);
                const ny = padding + Math.random() * (canvas.height - padding * 2);
                if(!isPointInWall(nx, ny)) {
                    objects.push({
                        id: Math.random().toString(36).substr(2, 5),
                        x: nx, y: ny, size: 20, 
                        color: OBJECT_COLORS[Math.floor(Math.random() * OBJECT_COLORS.length)],
                        rotation: Math.random() * 360
                    });
                    break;
                }
            }
        }

        function startMove(dir, event) { 
            if (event) event.preventDefault(); 
            sounds.playClick();
            moveState[dir] = true; 
        }
        function stopMove(event) { if (event) event.preventDefault(); moveState = { up: false, down: false, left: false, right: false }; }
        
        function rotateRobot(deg) { 
            sounds.playClick();
            robot.angle += deg; 
        }

        function setGripper(isOpen) {
            sounds.playGripper();
            robot.gripperOpen = isOpen;
            if (!isOpen) {
                const rad = robot.angle * (Math.PI / 180);
                const gX = robot.x + Math.cos(rad) * 30;
                const gY = robot.y + Math.sin(rad) * 30;
                let nearestIdx = -1;
                let minDist = GRAB_DISTANCE;
                objects.forEach((obj, idx) => {
                    const dist = Math.hypot(obj.x - gX, obj.y - gY);
                    if (dist < minDist) { minDist = dist; nearestIdx = idx; }
                });
                if (nearestIdx !== -1 && !robot.attachedObject) {
                    robot.attachedObject = objects[nearestIdx];
                    objects.splice(nearestIdx, 1);
                }
            } else if (robot.attachedObject) {
                const rad = robot.angle * (Math.PI / 180);
                const dropX = robot.x + Math.cos(rad) * 45;
                const dropY = robot.y + Math.sin(rad) * 45;
                if(isPointInWall(dropX, dropY)) {
                    robot.attachedObject.x = robot.x;
                    robot.attachedObject.y = robot.y;
                } else {
                    robot.attachedObject.x = dropX;
                    robot.attachedObject.y = dropY;
                }
                checkScoring(robot.attachedObject);
                robot.attachedObject = null;
            }
        }

        function checkScoring(obj) {
            let placed = false;
            dropZones.forEach(zone => {
                if (Math.hypot(obj.x - zone.x, obj.y - zone.y) < DROP_ZONE_SIZE * 0.8) {
                    placed = true;
                    if (obj.color === zone.color) { 
                        score += 10; 
                        updateScoreUI(); 
                        sounds.playScore(); 
                    }
                    else objects.push(obj);
                }
            });
            if (!placed) objects.push(obj);
        }

        function updateScoreUI() {
            const el = document.getElementById('scoreDisplay');
            if(!el) return;
            el.innerText = score.toString().padStart(3, '0');
            el.classList.remove('score-animate');
            void el.offsetWidth;
            el.classList.add('score-animate');
        }

        function update() {
            const spd = 3.5;
            let nextX = robot.x;
            let nextY = robot.y;
            const r = robot.angle * (Math.PI / 180);
            
            let isMoving = moveState.up || moveState.down || moveState.left || moveState.right;

            if (moveState.up) { nextX += Math.cos(r) * spd; nextY += Math.sin(r) * spd; }
            if (moveState.down) { nextX -= Math.cos(r) * spd; nextY -= Math.sin(r) * spd; }
            if (moveState.left) robot.angle -= 3;
            if (moveState.right) robot.angle += 3;

            // Handle Motor Sound
            if (isMoving) sounds.startMotor();
            else sounds.stopMotor();

            if (!isPointInWall(nextX, nextY)) {
                robot.x = nextX; robot.y = nextY;
            } else {
                if(!isPointInWall(nextX, robot.y)) robot.x = nextX;
                else if(!isPointInWall(robot.x, nextY)) robot.y = nextY;
            }

            robot.gripperValue += ((robot.gripperOpen ? 0 : 1) - robot.gripperValue) * 0.25;
            robot.pulse += 0.05;
            robot.x = Math.max(25, Math.min(canvas.width - 25, robot.x));
            robot.y = Math.max(25, Math.min(canvas.height - 25, robot.y));

            draw();
            updateUI();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = isDarkMode ? "#475569" : "#94a3b8";
            walls.forEach(w => {
                ctx.beginPath();
                ctx.roundRect(w.x + 2, w.y, WALL_W - 4, WALL_H, 4);
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.15)";
                ctx.lineWidth = 1;
                ctx.strokeRect(w.x + 8, w.y + 4, WALL_W - 16, WALL_H - 8);
            });

            dropZones.forEach(z => {
                ctx.save();
                ctx.strokeStyle = z.color; ctx.lineWidth = 3; ctx.setLineDash([8, 4]);
                ctx.beginPath(); ctx.arc(z.x, z.y, DROP_ZONE_SIZE/2, 0, Math.PI*2); ctx.stroke();
                const glow = Math.sin(robot.pulse) * 0.15 + 0.2;
                ctx.fillStyle = z.color; ctx.globalAlpha = glow; ctx.fill();
                ctx.globalAlpha = 1.0; ctx.setLineDash([]); ctx.fillStyle = z.color; 
                ctx.font = "bold 11px JetBrains Mono"; ctx.textAlign="center";
                ctx.fillText(z.label, z.x, z.y + 4);
                ctx.restore();
            });

            objects.forEach(o => {
                ctx.save();
                ctx.translate(o.x, o.y);
                ctx.rotate(o.rotation * Math.PI/180);
                ctx.fillStyle = o.color;
                ctx.fillRect(-10, -10, 20, 20);
                ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.lineWidth = 2; ctx.strokeRect(-10, -10, 20, 20);
                ctx.restore();
            });

            ctx.save();
            ctx.translate(robot.x, robot.y);
            ctx.rotate(robot.angle * (Math.PI/180));

            ctx.fillStyle = isDarkMode ? "rgba(0,0,0,0.3)" : "rgba(0,0,0,0.1)";
            ctx.beginPath(); ctx.ellipse(0, 4, 24, 20, 0, 0, Math.PI*2); ctx.fill();

            ctx.fillStyle = isDarkMode ? "#1e293b" : "#334155";
            ctx.roundRect(-22, -20, 44, 8, 4); ctx.fill();
            ctx.roundRect(-22, 12, 44, 8, 4); ctx.fill();
            
            ctx.strokeStyle = isDarkMode ? "#334155" : "#475569"; ctx.lineWidth = 1;
            for(let i = -18; i < 22; i+=6) {
                ctx.beginPath(); ctx.moveTo(i, -20); ctx.lineTo(i, -12); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(i, 12); ctx.lineTo(i, 20); ctx.stroke();
            }

            if (robot.attachedObject) {
                ctx.save(); ctx.translate(35, 0); ctx.fillStyle = robot.attachedObject.color;
                ctx.fillRect(-10, -10, 20, 20); ctx.strokeStyle = "white"; ctx.strokeRect(-10, -10, 20, 20);
                ctx.restore();
            }

            const bodyGrad = ctx.createLinearGradient(-18, 0, 18, 0);
            bodyGrad.addColorStop(0, "#2563eb"); bodyGrad.addColorStop(1, "#1d4ed8");
            ctx.fillStyle = bodyGrad; ctx.roundRect(-18, -14, 36, 28, 6); ctx.fill();
            
            ctx.fillStyle = "#0f172a"; ctx.beginPath(); ctx.arc(10, 0, 5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#ef4444"; ctx.beginPath(); ctx.arc(10, 0, 2, 0, Math.PI*2); ctx.fill();

            ctx.strokeStyle = isDarkMode ? "#cbd5e1" : "#475569"; ctx.lineWidth = 4; ctx.lineCap = "round";
            const gVal = 0.5 * robot.gripperValue;
            ctx.save(); ctx.translate(15, -7); ctx.rotate(gVal); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(20, -5); ctx.stroke(); ctx.restore();
            ctx.save(); ctx.translate(15, 7); ctx.rotate(-gVal); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(20, 5); ctx.stroke(); ctx.restore();
            ctx.restore();
        }

        function updateUI() {
            document.getElementById('valX').innerText = Math.round(robot.x);
            document.getElementById('valY').innerText = Math.round(robot.y);
            const cargo = document.getElementById('valCargo');
            cargo.innerText = robot.attachedObject ? "LOADED" : "EMPTY";
            cargo.className = robot.attachedObject ? "text-green-400 font-bold" : "text-orange-400";
        }

        document.body.addEventListener("touchstart", (e) => {
            if (e.target.closest('.joystick-btn') || e.target.type === 'range') return;
            e.preventDefault();
        }, {passive: false});

    </script>
</body>
</html>
